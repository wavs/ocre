%
%  Rapport de soutenance 1 // OCRe - HUGE Software
%
%  Created by Alexandre Testu on 2008-02-01.
%  Copyright (c) 2008 Epita. All rights reserved.
%
\documentclass[]{report}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc} 
\usepackage[french]{babel}

% Setup for fullpage use
\usepackage{fullpage}


\usepackage{fancyhdr}
% Multipart figures
%\usepackage{subfigure}
% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}
\ifpdf 
\usepackage[pdftex]{graphicx} \else 
\usepackage{graphicx} \fi 
\title{OCRe} 
\author{ \textsc{Huge} Software \\
\\
\\
Premi\`ere Soutenance \\
\\
\\
\textsc{Rapport}}

\date{}

\begin{document}

\ifpdf \DeclareGraphicsExtensions{.pdf, .jpg, .tif} \else \DeclareGraphicsExtensions{.eps, .jpg} \fi

\maketitle

\pagebreak

\tableofcontents 
\pagebreak

\part{Pr\'eparatifs} 

% (fold)
\label{prt:preparatifs}

\chapter{Gen\`ese} % (fold)
\label{cha:genese}
	\section{Naissance du groupe} % (fold)
	\label{sec:naissance_du_groupe} 
		Au commencement, il y avait quatre geeks. Trois rescap\'es de l'aventure Objectif:Mars trois ``poutreurs de l'espace'', c'est \`a dire Dimitri Georgoulis, Pierre Guilbert et Alexandre Testu ainsi qu'une nouvelle recrue, le sieur Thomas A\"it-taleb. Nous sommes tous des amis proches, et nous pensons que c'est ce qui nous diff\'erencie de beaucoup d'autres groupes: nous sommes soud\'es. Les diff\'erends qu'il peut y avoir au sein du groupe se r\`egle d'un claquement de doigt, et les choix que l'\'equipe a eu \`a faire ont toujours \'etait fait \`a l'unanimit\'e.
		\paragraph{\textsc{Huge}?, OCRe?} % (fold)
		\label{par:huge_ocre_}
			Pourquoi \textsc{Huge}? Nous m\^eme avons du mal \`a l'expliquer. L'expression remonte \`a l'ultime ``coding week'' de sup, durant laquelle ``Huge!'' est devenu une sorte de signe de ralliement. Tout n'\'etait que hugeitude \`a cette \'epoque.
			Pourquoi OCRe? Les trois premi\`eres lettres sont \'evidentes, et la troisi\`eme n'est autre que le ``e'' d'Epita. De plus, OCRe est plus facile \`a prononcer qu'``OCR''.
		% paragraph huge?_ocre_ (end)
	% section naissance_du_groupe (end)

	\section{Choix du sujet} % (fold)
	\label{sec:choix_du_sujet} 
		Le fait de choisir de r\'ealiser un OCR est apparu comme une \'evidence pour tous les membres du groupe. Nous avons d\'ej\`a fait de la 3D l'ann\'ee derni\`ere, et le fait de d\'evelopper un logiciel de \emph{reconaissance d'\'ecriture} nous fascine tous les quatre. 
	% section choix_du_sujet (end)
% chapter genese (end)

\chapter{Organisation} % (fold)
\label{cha:organisation}
	On entend par organisation du projet la r\'epartition des t\^aches, la communication entre les membres du groupe
	\section{Applications utilis\'ees} % (fold)
	\label{sec:applications_utilis'ees}
		\subsection{En ligne} % (fold)
		\label{sub:en_ligne}
			\paragraph{Basecamp\\} % (fold)
			\label{par:basecamp}
			Basecamp\footnote{\emph{http://www.basecamphq.com/}} est une application web de gestion de projet. Elle est développ\'e en Ruby on Rails par une start up bas\'ee \`a Chicago, 37Signals. Cette application est tr\`es intuitive, elle nous a beacoup aid\'e \`a collaborer de mani\`ere plus efficace que pendant le projet de Sup. Basecamp a \'et\'e recommand\'ee par le Wall Street Journal, Time, Business 2.0 ou encore BusinessWeek.
			% paragraph basecamp (end)
			\paragraph{Bubbl.us\\} % (fold)
			\label{par:bubbl_us}
			Il s'agit d'un logiciel de \emph{brainstorming} en Flash. Nous l'avons utilis\'e pour mieux visualiser la strusture qu'allait prendre notre OCR. La structure obtenue est visible en annexe. %ANNEXE
			% paragraph bubbl_us (end)
			\paragraph{Wordpress\\} % (fold)
			\label{par:wordpress}
			Nous utilisons la plateforme de publication Open Source Wordpress pour notre site web. En effet, nous aurions tr\`es bien pu passer du temps \`a d\'evelopper nos propre script PHP. Mais jamais ils ne serait jamais arriv\'e \`a la cheville de Wordpress. Exit le PHP donc, nous n'aurons qu'\`a toucher \`a du CSS et du HTML.
			% paragraph wordpress (end)
			% subsection en_ligne (end)
		\subsection{Hors ligne} % (fold)
		\label{sub:hors_ligne}
			\paragraph{Emacs\\} % (fold)
			\label{par:emacs}
				C'\'etait soit \c ca soit Vi\ldots
			% paragraph emacs (end)
			\paragraph{TextMate\\} % (fold)
			\label{par:textmate}
				TextMate est le meilleur \'editeur de texte disponible sur Mac (oui, un troll se cache dans cette phrase). Plus s\'erieusement, le Mac \emph{user} du groupe, Alexandre Testu, celui qui r\'edige ce rapport \`a la troisi\`eme personne appr\'ecie l'auto-compl\'etion en \LaTeX qu'offre TextMate.
			% paragraph textmate (end)
			\paragraph{Subversion\\} % (fold)
			\label{par:subversion}
				Nous avons enregistr\'e OCRe sur Google Code\footnote{\emph{http://code.google.com/p/ocre}}. Pourquoi pas Sourceforge ou autre? Google Code offre tout d'abord une interface bien plus agr\'eable, il n'y a pas de publicit\'es qui prennent un tiers de la page comme sur Sourceforge. De plus, nous avons un Wiki \`a notre disposition. Google Code nous est donc apparu comme le meilleur choix pour nous comme pour nos futurs utilisateurs.
			% paragraph subversion (end)
			\paragraph{Glade} % (fold)
				Glade est un logiciel qui facilite le d\'eveloppement d'interface en Gtk. Pour plus de d\'etail, se r\'ef\'erer \`a %REF
			\label{par:glade}
			% paragraph glade (end)
		% subsection hors_ligne (end)
	% section applications_utilis'ees (end)
% chapter organisation (end)

% part preparatifs (end)




\part{Ce qu'on a fait} % (fold)
\label{prt:ce_qu_on_a_fait}

% A VERFIER (wavs)
	
  \chapter{Repr\'esentation des images} % (fold)
	\label{cha:repr'esentation_des_images}
	
  
    \section{Niveaux de repr\'esentation des images} % (fold)
    \label{sec:niveaux_de_repr'esentation_des_images}
  		Il existe de nombreuses manières de représenter les images en traitement numérique. On ordonne ces représentations selon une échelle d'abstraction. On distingue alors quatre principaux niveaux de représentation qui s'échelonnent du signal pour le moins abstrait jusqu'aux modèles relationnels constituant un haut niveau d'abstraction.
      
      En ce qui concerne le plus bas niveau d'abstraction, il y a la représentation "images iconiques", à savoir la représentation qui contient les données graphiques originales. Cette représentation est notamment utilisée durant le prétraitement de l'image (concernant le redressement, le débruitage ou encore le seuillage).
      
      Le second niveau d'abstraction est celui qui consiste à segmenter les images. Formées de différentes parties représentant des groupes de pixels agglutinés, l'image est ainsi segmentée afin de dégager des formes (ou objets) en particulier pour les traiter par la suite.
      
      La représentation géométrique constitue le troisième niveau de représentation. Les images sont ainsi caractérisées selon des données de forme 2D ou 3D. Cette représentation est utilisé notamment pour les simulations d'éclairage par exemple en CAO (Conception Assistée par Ordinateur).
      
      Enfin au plus haut niveau de l'échelle d'abstraction, on trouve les modèles relationnels qui permettent de traiter plus efficacement les données en les organisant par exemple sous la forme de réseaux sémantiques [Nilsson, 1982]. Les modèles relationnels consistent comme leurs noms l'indiquent, à mettre en relation plusieurs éléments de l'image afin de mieux comprendre et de mieux percer la signification de l'image.
      
    % section niveaux_de_repr'esentation_des_images (end)
    
    \section{Structures de donn\'ees images} % (fold)
    \label{sec:structures_de_donn'ees_images}
      Afin de représenter les images selon les précédents niveaux d'abstraction, nous avons besoin de structures contenant les données de l'image et implémentables en mémoire. On distingue parmi celles-ci deux grands types de structures. D'un côté, il y a les structures traditionnelles, consituées des matrices, des chaines ainsi que des structures topologiques et relationnelles. De l'autre côté, se trouvent les structures hiérarchiques telles que les pyramides et les arbres quaternaires.
      
      Certainement les plus connues et les plus communes, les matrices sont un moyen simple et efficace de représenter des images. Elles constituent une représentation bas-niveau des données graphiques. Chaque élément de la matrice représente un entier correspondant à la luminosité ou encore les trois composantes de couleurs RGB (ou une autre propriété élémentaire de l'image) d'un pixel (pour PICTure ELement). Le pixel dont les coordonnées seront (x,y) correspondra à l'élément (x,y) de la matrice,plus précisement à l'intersection de la ligne x et de la colonne y. Cette représentation sous forme de matrices implique certaines relations spatiales, notamment celles du voisinage, qui s'avère utile pour certains traitements de l'image. Les images binaires, les images constituées de plusieurs bandes spectrales (i.e. (Alpha) Rouge Vert Bleu) ainsi que les structures hiérarchiques constituent des exemples spécifiques d'images représentées à l'aide de matrices.
      
       % Insertion image: matrix.jpg
       
      Au stade actuel d'avancement du projet, nous représentons les images grâce au matrices, notamment pour le prétraitement de l'image. En ce qui concerne la partie extraction des lignes/caractères, nous avons décidé de les représenter par le biais d'une matrice binaire (0 pour un pixel blanc, 1 pour un pixel noir), décrite dans la structure s_binary_image.
      
      \begin{verbatim}
				struct s_binary_image
        {
          char *name;
          int width;
          int height;
          int **data;  /* Matrix of binary integer */
          int *hproj;  /* Horizontal projection vector */
        };
			\end{verbatim}
      
      D'autres structures traditionnelles d'images existent. Les chaines sont un autre moyen de représenter les données graphiques. Le principe consiste à décrire les bords de l'objet que l'on veut représenter. Le contour est défini par la coordonnée de son pixel de référence et la séquence de symboles correspondant à l'orientation du pixel suivant. Chaque élément de la chaine correspond à un symbole basique de l'image, en somme un pixel. Les chaines codes ou Freeman codes [Freeman,1961] sont utilisées pour les données représentant des séquences de symboles. Côté implémentation, les chaines peuvent être représentéespar un vecteur de préférence une liste chainée.
      
      % Insertion image: chaincodes.jpg
      
      Il est également possible de représenter plus abstraitement les images par des structures topologiques, telles que des graphes. Ces structures sont constituées d'un ensemble d'éléments et leurs relations, à savoir respectivement les sommets et les arcs du graphe. Ces graphes peuvent bien entendu être valués par un poids. Pour représenter des images, on se sert d'un graphe de régions d'adjacence où les sommets sont des régions de l'image et les arcs sont les bords, à savoir les relations de voisinage. Le graphe de régions d'adjacence est créé à partir d'une matrice contenant les labels des régions de l'image, appellée "region map". Cette structure peut être utilisée pour filtrer un motif dans le cadre de la reconnaissance de symboles par exemple.
      
      % Insertion image: topo.jpg
      
      Pour un haut niveau d'abstraction, il existe les structures relationnelles, qui consiste à lier plusieurs données entre elles afin de représenter une image. Ce type de structure s'inspire grandement des bases de données relationnelles. La structure permet de lier entre elles les parties sémantiques de l'image. Ce type de structure est envisage dans la plupart des cas après avoir segmenter notre image de départ en plusieurs objets distincts.
      
      % Insertion image: relationnel.jpg
      
      En ce qui concerne les structures hiérarchiques de données, on distingue tout d'abord les pyrammides, qui se décomposent elles mêmes en deux types: les M-pyramides (à base de matrices) et les T-pyramides (à base d'arbres). Les pyramides sont composées d'une séquence d'images de différentes résolutions. Cette propriété rend donc les pyramides très pratique pour une utilisation en parallèle.
      
      L'autre structure arborescente est l'arbre quaternaire (ou quadTree). C'est une structure dérivée des pyramides. D'ailleurs l'année dernière dans le cadre du partitionnement de l'espace 3D, nous avions fait appel à un octree, qui n'est autre que la généralisation des quadtree à l'espace. Pour revenir aux arbres quaternaires, leur principe est que l'image à représenter est soit une image de couleur uniforme, soit la réunion de quatre sous-images carrées de mêmes tailles. Cette structure est comme son nom l'indique une structure arborescente où les feuilles contiennent les couleurs des sous-images. Les arbres quaternaires sont utilisés entre autres pour la compression d'images, en effet ils permettent de miniser l'information nécessaire pour coder des zones homogènes. Cependant, l'ensemble des images pour lesquelles la compression par quadtree est efficace, est restreint.
      
      
    % section structures_de_donn'ees_images (end)
	
	% chapter repr'esentation_des_images (end)

  
	\chapter{Analyse de l'image et extraction} % (fold)
	\label{cha:analyse_de_l'image_et_extraction}
	
    \section{D\'etection des lignes} % (fold)
    \label{sec:d'etection_des_lignes}
      Après prétraitement de l'image, on obtient une image "parfaite", à savoir redressée, débruitée et seuillée. C'est ensuite à la partie extraction de mettre en place la détection des lignes de l'image et l'extraction des caractères afin de pouvoir donner à la partie reconnaissance les caractères isolés. La partie extraction est également responsable de la détection des blocs dans l'image, tels que des blocs de texte, des schémas, des images ou encore des tableaux.
      Cette partie analyse de l'image et extraction se déroulera dans l'ordre suivant: tout d'abord, nous devons détecter les blocs de l'image afin de pouvoir effectuer le traitement adéquate selon le type de bloc. En ce qui concerne le traitement des blocs de texte, on effectue une détection des lignes puis une extraction des caractères et enfin on passe les caractères aux réseaux de neurones.
      
      Pour cette soutenance, nous avons réalisé la détection des lignes conformément au planning. Cette détection des lignes se concrètise en un exécutable nommé "extract" dans le répertoire /extraction du projet. Il dispose de plusieurs options comme l'aide -h, l'attribution du nom de fichier d'entrée -i file et celui de sortie -o file. Cette exécutable prend en entrée une image bitmap noir&blanc "parfaite" et génère un fichier bitmap fidèle au fichier original tout en ayant préalablement encadrè les lignes détectées.
      Le traitement appliqué à l'image se décompose en cinq parties. En premier lieu, l'image source est chargée dans une surface à l'aide de la librairie SDL. D'après cette surface, nous créons une matrice binaire représentant l'image. Nous effectuons ensuite la projection horizontale de cette matrice.
      La projection horizontale consiste à calculer le nombre de pixels noirs sur chaque ligne. On obtient ainsi un vecteur de projection, à savoir l'histogramme de projection horizontale de longueur la hauteur de l'image.
      
      % Formule mathématique de la projection horizontale
      
      Ensuite, la détection des lignes consiste à parcourir le vecteur de projection horizontale à la recherche des plages blanches (où il y a peu de pixels noirs) représentant les interlignes ainsi que les plages noires, à savoir les lignes de texte. 
      Cependant, appliqué tel quel, cet algorithme est peu robuste face aux pixels parasites (i.e. des tâches). En effet, ces pixels parasites auraient la facheuse tendance à être pris pour des lignes à part entière. C'est pourquoi lors de la détection des lignes, nous devons vérifier que les lignes détectées sont d'une hauteur suffisante. C'est pourquoi nous avons utilisé un certain seuil pour considérer une plage de pixels en tant que ligne. Afin que ce seuil soit le plus adapté, nous l'avons fixé à 8 pixels pour une résolution de 300 Points par Pouce. Les lignes détectées sont stockées dans une liste chainée de structure s_line_set définie comme ceci:
      
      \begin{verbatim}
        struct s_line_set
        {
          int id;
          int pos;
          int height;
          struct s_character_set *charlist;
          struct s_line_set *next;
        };
      \end{verbatim}
      
      Cette structure est composé de plusieurs caractéristiques de la ligne, notamment sa position et sa hauteur qui nous permettent de la localiser dans l'image de départ.
      Une fois le résultat obtenu, nous générons une image présentant les lignes détéctées dans des cadres et enfin nous sauvegardons le fichier bitmap. Ces deux opérations ne nous seront utiles seulement dans le cadre de la présentation de la détection des lignes lors de la soutenance. En effet, la génération d'un fichier preview ne nous sera pas utiles dans la suite du projet.
      
    % section d'etection_des_lignes (end)
    
    \section{M\'ethodes de s\'egmentation} % (fold)
    \label{sec:m'ethodes_de_s\'egmentation}
  		
      
    % section m'ethodes_de_s\'egmentation (end)
	
	% chapter analyse_de_l'image_et_extraction (end)

  % A VERIFIER (wavs)

	\chapter{Pr\'etraitement} % (fold)
	\label{cha:pr'etraitement}
	
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%%%%%%%%%%%%%%%%%%%%%% FIXME
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%%%%%%%%%%%%%%%%%%%%%% PIERRE
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
	% chapter pr'etraitement (end)

	
	\chapter{R\'eseau de neurones} % (fold)
	\label{cha:r'eseau_de_neurones}
	
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%%%%%%%%%%%%%%%%%%%%%% FIXME
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%%%%%%%%%%%%%%%%%%%%%% DIMITRI
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
	% chapter r'eseau_de_neurones (end)


	\chapter{Interface graphique} % (fold)
	\label{cha:interface_graphique}
	Je vais commencer par expliqu\'e les outils et la m\'ethode qu'on a utilis\'e pour la r\'ealisation de l'interface, puis je d\'etaillerais \`a quoi ils nous ont servi.
		\section{Gtkoi?} % (fold)
		\label{sec:gtkoi_}
			Le cahier des charges nous impose une interface utilisant la biblioth\`eque Gtk. On a donc commenc\'e par se documenter sur Gtk.
			Gtk signifie ``The GIMP Toolkit'', puisque Gtk a \'et\'e cr\'e\'e pour le logiciel de traitement d'images ``The GIMP''. C'est en fait un ensemble de biblioth\`eques utilis\'e pour r\'ealiser des interfaces graphiques. Et \c ca n'avait pas l'air simple \`a utiliser.
			Heureusement, nous avons rapidement d\'ecouvert qu'il existe un outil qui va nous simplifier la vie. Il se nomme Glade. C'est un outil qui simplifie grandement la cr\'eation de l'interface pour nous permettre de nous concentrer sur le code ``pur''. Glade 3 fonctionne tr\`es bien sur les machines du PIE. Il a le m\'erite de nous offrir une interface assez intuitive, je l'ai donc pris en main tr\`es rapidement.
			Nous cr\'eons donc une interface en utilisant Glade puis nous relions chaque ``signal'' dans un \texttt{.c}. Les ``signals'' sont des sortes d'``\'ev\`enement'' auquel on peut relier une action en utilisant Gtk.
			Pour relier un signal \`a une action, on utilise la fonction suivante:
			
			\begin{verbatim}
				glade_xml_signal_connect (gxml, "on_window_destroy",
							    G_CALLBACK (gtk_main_quit));
			\end{verbatim}
			
			Ici, \verb!gxml! est notre fichier xml, \verb!"on_window_destroy"! est le signal auquel on rattache la fonction Gtk \verb!gtk_main_qui! qui quitte l'application en cours. Cette simple ligne de code nous permet de signifier au programme que lorsqu'on clique sur la ``croix'' en haut \`a droite de notre fen\^etre, 
			
			
			
		% section gtkoi_ (end)
		
	% chapter interface_graphique (end)
	
	\chapter{Site Web} % (fold)
	\label{cha:site_web}
		\section{Ce qu'on veut} % (fold)
		\label{sec:ce_qu_on_veut}
		Le site web\footnote{\emph{http://huge.ocre.free.fr}} est la premi\`ere chose que verra l'utilisateur potentiel. Il devra donc \^etre \`a la fois attirant et bien ordonn\'e. Le site devra comporter:
		\begin{itemize}
			\item Une page d'accueil qui expliquera bri\`evement ce qu'est notre projet, qui nous sommes, etc\ldots
			\item Une page de d\'eveloppement qui contiendra un lien vers notre page Google Code.
			\item Une page de t\'el\'echargement qui listera chronologiquement tout ce qu'on a cr\'e\'e, c'est \`a dire nos sources, les \'ex\'ecutables et les rapports de soutenances.
			\item Une partie ``blog'' qui informera le visiteurs du stade de d\'eveloppement du projet.
			\item Une page d'``A propos'' qui expliquera plus en d\'etail qui nous somme, ce qu'est l'Epita, etc\ldots
		\end{itemize} 
		% section ce_qu_on_veut (end)
		\section{Comment on s'est d\'ebrouill\'e} % (fold)
		\label{sec:comment_on_s_est_d'ebrouill'e}
		Comment on s'est débrouillé

			On est parti avec l'idée que le site web ne devrait pas nous éloigner de notre tâche principale: développer un logiciel de reconnaissance de caractères. Il fallait donc trouver un moyen rapide pour construire ce site. Nous nous sommes donc tournés vers la plateforme de publication open source Wordpress.
			Nous avons pleinement conscience que ce choix nous empêchera d'apprendre en détail des langages tels que le PHP. Cependant, entre passer plus de temps à peaufiner notre OCR et coder un script de news, il n'y a pas photo!

			Wordpress s'installe très facilement sur notre site. Un glisser-déposer et 3 clics plus tard, notre site fonctionne. Par contre, il ressemble à n'importe quel blog, pas du tout au site d'une boite de logiciel. Qu'à cela ne tienne, Alexandre sort CSSEdit\footnote{http://macrabbit.com/cssedit/} de son dossier Applications, et quelques heures plus tard\ldots tadam\footnote{http://huge.ocre.free.fr/}!

		Finalement, même si nos connaissances du PHP se limite toujours à\ldots pas grand chose, on a construit un site ergonomique, tout en apprenant un autre langage, le CSS.

		% section comment_on_s_est_d'ebrouill'e (end)
	% chapter site_web (end)
% part ce_qu_on_a_fait (end)



\part{Ce qu'on compte faire} % (fold)
\label{prt:ce_qu_on_compte_faire}

	\chapter{Analyse de l'image et extraction} % (fold)
	\label{cha:analyse_de_l'image_et_extraction}
	
    \section{D\'etection des caractères} % (fold)
    \label{sec:d'etection_des_caractères}
      Pour les prochaînes soutenances, nous devrons réaliser une détection des caractères fonctionnelle qui sera robuste vis-à-vis des pixels parasites, du chevauchement des caractères et du défaut d'encrage excessif ou insuffisant. Pour cela, on utilisera vraisemblablement la projection verticale des pixels pour chaque ligne détectée. Pour le problème des pixels parasites, on incluera un seuil. En ce qui concerne le  chevauchement de caractères, on devra vérifier que les transitions entre l'arrière plan et les caractères ainsi que la connexité possible entre deux caractères, nous serons vraisemblablement ammené à utiliser une représentation topologique tel qu'un graphe. Pour les éventuelles problèmes d'encrage insuffisant, nous ferons appel à un autre seuil minimum de largeur de caractère. Enfin dans le cas d'un encrage excessif, on utilisera l'algorithme dit du "Break Cost".
      
    % section d'etection_des_caractères (end)
    
    \section{S\'egmentation} % (fold)
    \label{sec:s\'egmentation}
  		Nous devrons implémenter une méthode de détection de bloc afin de pouvoir différencier les blocs de texte à ceux d'images ou de graphiques. Comme énoncé dans précédemment, plusieurs méthodes s'offrent à nous pour effectuer ce traitement. Nous devrons également trouvé une structure de données permettant de stocker ces différents blocs et leurs caractéristiques propres mais également une structure permettant de garder en mémoire les propriétés du texte, à savoir les paragraphes ou encore les tabulations.
      
    % section s\'egmentation (end)
	
	% chapter analyse_de_l'image_et_extraction (end)

% part ce_qu_on_compte_faire (end)



\bibliographystyle{plain} 
\bibliography{} \end{document} 
