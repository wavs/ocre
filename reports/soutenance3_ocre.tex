%---DOCUMENT-------------------------------------------------------------------

\documentclass[a4paper,10pt]{report}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}

%---PACKAGES-------------------------------------------------------------------

\usepackage{makeidx} \makeindex
\usepackage[Rejne]{fncychap}				% Lenny, Conny ,Bjarne, Rejne, Glenn, Sonny
\usepackage{fancyhdr}
\usepackage{eurosym}
\usepackage{lastpage}
\usepackage{a4wide}
\usepackage[french]{minitoc}
\usepackage[hmargin=3.5cm,vmargin=2cm]{geometry}

%---SORTIES--------------------------------------------------------------------

\newif\ifpdf

\ifx\pdfoutput\undefined
   \pdffalse
\else
   \ifnum\pdfoutput=0
      \pdffalse
   \else
      \pdfoutput=1 \pdftrue
   \fi
\fi


%---PDF------------------------------------------------------------------------

\ifpdf
\usepackage[pdftex]{graphicx, color}
\graphicspath{{images/}}
\DeclareGraphicsExtensions{.jpg,.png,.gif}
\pdfcompresslevel=9

\usepackage[pdftex, 					% Paramétrage de la navigation
bookmarks = true, 						% Signets
bookmarksnumbered = true, 		% Signets numérotés
pdfpagemode = None, 					% None, UseThumbs, UseOutlines, Fullscreen
pdfstartview = FitH, 					% FitH, FitV, FitR, FitB, FitBH, FitBV, Fit
pdfpagelayout = OneColumn, 		% SinglePage, OneColumn, TwoColumnLeft, TwoColumnRight
colorlinks = false, 					% Liens en couleur
urlcolor = black, 						% Couleur des liens externes
pdfborder = {0 0 0} 					% Style de bordure : ici, rien
]{hyperref}

\hypersetup{
pdfauthor = {\textsc{Huge Software}\\ Thomas A\"it-Taleb, Dimitri Georgoulis, Pierre Guilbert et Alexandre Testu}, 							% Auteurs
pdftitle = {Rapport de soutenance}, 								% Titre du document
pdfsubject = {Soutenance Finale}, 							% Sujet
pdfkeywords = {}, 						% Mots-clefs
pdfcreator = {}, 							% Logiciel qui a crée le document
pdfproducer = {} 							% Société avec produit le logiciel
plainpages = false}
\usepackage{pdfpages}

%---DVI------------------------------------------------------------------------

\else
\usepackage{graphicx}
\graphicspath{{eps/}}
\newcommand{\url}[1]{\emph{#1}}
\newcommand{\href}[2]{\emph{#2}[1]}
\fi

%---EN-TETE-ET-PIED-DE-PAGE----------------------------------------------------

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\pagestyle{fancy}

%\lhead{}
%\chead{}
%\rhead{}
%\lfoot{}
%\cfoot{}
%\rfoot{}

%---PAGE-DE-GARDE--------------------------------------------------------------

\title{\textsc{Rapport de Soutenance} \\ Soutenance Finale}
\author{\textsc{Huge Software}\\ \\ Thomas A\"it-Taleb \\ Dimitri Georgoulis \\ Pierre Guilbert \\ Alexandre Testu}
\date{}

%---COLOR---------------------------------------------------------------------

%\pagecolor{}
% \color{}

%---DEBUT-DU-DOCUMENT----------------------------------------------------------



\begin{document}
\lstset{language=C}
\dominitoc
\maketitle
\tableofcontents \pagebreak
\thispagestyle{fancy}

\chapter{Introduction} % (fold)
\label{cha:introduction}

Ce document que vous avez en main est le rapport du projet ``OCRe'', le fruit de plusieurs mois de travail de quatre étudiants: Thomas Aït-taleb, Pierre Guilbert, Dimitri Georgoulis, et Alexandre Testu. \\
Vous tenez entre vos mains de nombreuses heures de stress, d’angoisse, de déceptions, mais aussi de joies, de découvertes, et surtout de camaraderie. Car OCRe est le fruit d’un travail d’équipe, d’une équipe aux membres très différents, mais qui, curieusement, tient debout. Oh, bien sûr, nous avons eu nos différends, tout le monde n’était pas toujours de bonne humeur, mais il y en avait toujours un pour redresser la situation et pousser les autres vers l’avant.

% chapter introduction (end)

\section{Un OCR, what else?} % (fold)
\label{sec:un_ocr_what_else_}
Lorsque j’ai expliqué à ma mère le but de mon projet (``on doit réaliser un logiciel qui transformera une image en texte''), elle n’a pas compris. Je lui ai ré-expliqué en lui disant que l’on entrera du texte scanné, une image donc, et que notre logiciel reconnaîtra ce texte. Elle n’a toujours pas compris, et aujourd’hui encore ne comprend pas l’intérêt de notre application – il est utile de préciser que ma mère ne sait pas se servir d’un répondeur, mais qu’elle fait le meilleur coq au vin du monde. \\
Au fil du temps, je me suis rendu compte que ce n’était pas seulement ma mère qui ne comprenait pas, mais tout les gens qui n’utilisent pas régulièrement un ordinateur. Ils sont resté dans une logique d’\emph{impression}. L’ordinateur n’est pour eux qu’un lieu de passage pour leurs documents. Ces documents n’existent pas \emph{vraiment} s’ils ne sont pas sur du papier. \\
Or dans le monde dans le quel nous vivons et dans lequel nous \emph{vivrons}, le papier a de moins en moins d’importance. Nous souhaitons sa mort, et ce le plus rapidement possible. C’est pour ça que nous avons choisis ce projet, c’est parce que nous souhaitons développer une application réellement utile, voire indispensable. \\
Notre application est une machine à tuer le papier, elle extrait l’âme du papier – son contenu – pour nous permettre de le brûler avec un rictus machiavélique. \\

Plus sérieusement, nous croyons dur comme fer à la nécessité d’une telle application dans le monde d’aujourd’hui, alors qu’une application qui transforme des cartes 2D en modèles 3D, c’est certes \emph{cool}, mais ça s’arrête là. Nous croyons surtout que l’OCR peut être – et doit être – une application qui puisse être utiliser par \emph{tout le monde}. Tout le monde devrait pouvoir enregistrer facilement leurs documents papier sur leur ordinateur. Tout le monde devrait pouvoir, en un seul clic, obtenir le texte contenu dans un document scanné. C’est donc dans cette optique que nous avons choisi le projet de l’OCR, en souhaitant réaliser non pas une application compliquée, pleine d’options, mais un logiciel simplissime, qui n’ait qu’une seule fonction, mais qui la remplisse correctement.
% section un_ocr_what_else_ (end)

\chapter{Analyse et extraction}

\section{Rappel des faits}

La partie analyse et extraction a pour but, comme son nom l'indique, d'analyser la
structure du document et d'extraire les caractères afin de pouvoir les communiquer à la
partie reconnaissance des caractères. Durant les deux premières soutenances, nous vous
avons présenté plusieurs principes de détection. Lors de la première soutenance, nous nous
sommes attachés à détecter les lignes en utilisant la méthode des projections de pixels.
Durant la deuxième soutenance, nous vous avons présenté la détection des
caractères. Celle-ci faisait appel à une méthode de segmentation par croissance de régions.
Cependant, à ce stade notre algorithme était seulement capable de récupérer les
composantes connexes, constituant ainsi les caractères. Pour les besoins de l'OCR, il
devenait impératif de regrouper l'ensemble de ces caractères en blocs. Ces mêmes blocs
nous renseigneraient ainsi sur la structure du document analysé. Pour réaliser cette
détection des blocs, nous avons donc continué sur notre voie en appliquant la fameuse
croissance des régions.

\begin{center}
  \includegraphics[width=130mm]{screenshot.jpg}
  \caption{\emph{Extrait d'un document segment\'e}}
\end{center}



\section{Principe de la segmentation}

La méthode de segmentation que nous avons utilisée pour cette soutenance est la suite
de celle là même utilisée lors de la dernière soutenance. C'est la méthode par segmentation
de régions (region-based segmentation), plus précis\'ement par croissance de régions
(growing-region segmentation). Elle est composée de deux étapes principales que l'on peut
associer respectivement au travail réalisé lors des deux dernières soutenances:

\begin{enumerate}
\item Trouver les points de départ de nos régions.
\item Faire grossir nos régions par agglomération des pixels voisins.
\end{enumerate}

La première étape, réalisée lors de la 2ème soutenance, consiste donc à trouver les
composantes connexes qui constitueront les points de départ de nos régions. Nous ne
détaillerons pas ici le principe de cette étape qui a déjà été abordée dans le rapport de la
2ème soutenance.

Nous nous intéressons ici à la deuxième étape de la segmentation, qui consiste à faire
croître nos régions par agglomération des composantes connexes entre elles. Nous
travaillons ici sur les composantes connexes qui nous sont fournies par la 1ère étape sous
forme d'une liste triée en ordre croissant de composantes connexes. Pour la suite du
rapport et la clarté de l'explication, les composantes connexes seront
assimilés aux caractères.

\begin{center}
  \includegraphics[width=90mm]{croissance.jpg}
  \caption{\\\emph{Explication du principe de segmentation par croissance de r\'egions}}
\end{center}



\section{Hierarchie des informations}

Pour implémenter cette deuxième étape de l'algorithme de segmentation par régions,
nous avons fait appel à de nouvelles structures de données. Celles-ci nous permettent
ainsi de représenter des mots, des lignes et des blocs de texte, que nous appellerons plus
communément des paragraphes. Ces nouvelles structures de données s'ajoutent à la
structure de composantes connexes qui est la structure atomique employée par
l'algorithme. En effet, dans notre cas, on ne peut pas décomposer des composantes
connexes, ce sont nos points de départs et les paragraphes seront ceux d'arrivée. Ces
différentes structures de données sont à employer selon une hiérarchie bien précise. Les
caractères (composantes connexes) constituent des mots, qui composent des lignes, qui
créent des paragraphes.

Afin de représenter ces données en mémoire, nous avons principalement repris la
structure des composantes connexes en la modifiant selon nos besoins. Nos données seront
donc stockées en mémoire grâce à des listes chaînées triées de caractères, de mots, de
lignes et de paragraphes. Voici les quatre types principaux nous permettant de représenter
les différents éléments cités ci-dessus:

\begin{lstlisting}
struct s_cc_elt
{
    int id;
    int nbpix;
    struct s_box_coordinate coord;
    int chr;
    struct s_cc_elt *next;
}

struct s_word_elt
{
    struct s_cc_list *cclist;
    struct s_box_coordinate coord;
    struct s_word_elt *next;
}

struct s_line_elt
{
    struct s_word_list *wordlist;
    struct s_box_coordinate coord;
    struct s_line_elt *next;
}

struct s_paragraph_elt
{
    struct s_line_list *linelist;
    struct s_box_coordinate coord;
  struct s_paragraph_elt *next;
}
\end{lstlisting}


Voici la hiérarchie des types de données utilisés. Vous pouvez constater qu'ils sont
similaires dans leurs structures. Ainsi, un paragraphe est constitué de ses propres
coordonnées et de la liste de lignes le composant. Cette même liste de lignes est composée
de ses coordonnées et de la liste des mots qui la composent. Et enfin cette liste de mots
possède ses propres coordonnées et la liste des caractères qui le composent. L'algorithme 
d'agglomération des éléments devra parcourir l'ensemble des caractères pour
créer ainsi une liste de mots qui sera elle-même parcourues pour fournir une liste de lignes
et ainsi de suite jusqu'à obtenir la liste des blocs de texte: les paragraphes.

\begin{center}
  \includegraphics[width=90mm]{hierarchie.jpg}
  \caption{\\\emph{Hi\'erarchie des informations}}
\end{center}



\section{Impl\'ementation}

La première phase de la segmentation, à savoir la recherche des composantes connexes
est effectuée par la fonction findCC(), comme explicitée dans le précédant rapport. Cette
fonction nous renvoie une liste triée de composantes connexes. Cette liste constitue le
départ de la deuxième phase de la segmentation. La phase de croissance des régions se
réalise en trois étapes effectuées par trois fonctions principales dont voici les prototypes:

\begin{lstlisting}
t_word_list *makeWords(t_cc_list *cc_list);

t_line_list *makeLines(t_word_list *word_list);

t_paragraph_list *makeParagraphs(t_line_list *line_list);
\end{lstlisting}

Ces trois fonctions créent séquentiellement une liste de mots puis une liste de lignes et
enfin une liste de paragraphes. Voyons plus en détails leur fonctionnement respectif.
   
La fonction makeWords() prend en paramètre une liste de composantes connexes et
renvoie la liste des mots qu'elle a formés. Cette fonction parcourt la liste des composantes
connexes. Au premier caractère trouvé, elle crée un mot auquel elle associe une liste de
caractères. Tant que les caractères suivants respectent un seuil vertical et un seuil
horizontal spécifique alors on ajoute ces caractères au mot précédemment créé sinon on en
crée un autre. Le seuil vertical permet d'éviter d'ajouter des caractères provenant d'une
autre ligne et le seuil horizontal permet d'éviter d'ajouter des caractères trop espacés qui
feraient partis d'un autre mot.

\begin{center}
  \includegraphics[width=100mm]{seuils.jpg}
  \caption{\\\emph{Pr\'esentation des seuils horizontal et vertical}}
\end{center}

Selon le même modèle, la fonction makeLines() prend en paramètre une liste de mots et
renvoie une liste de lignes qu'elle a constituées. Cette fonction parcourt la liste des mots. Au
premier mot trouvé, elle crée une ligne et lui associe une liste de mots la composant. Elle
détecte les mots qui sont sur la même ligne grâce à un seuil vertical selon le même principe
que le seuil vertical de la fonction makeWords(). La fonction makeParagraphs() fonctionne
sur le même principe que les précédentes fonctions à ceci près qu'elle se situe à un niveau
supérieur dans la hiérarchie des données.



\section{Standardisation}

Une fois l'image segment\'ee, on se doit de stocker les informations obtenues pour que l'on puisse
les analyser ult\'erieurement. C'est pourquoi nous avons commenc\'e \`a d\'evelopper un module
permettant de sauvegarder aussi bien la structure lin\'eaire du document, \`a savoir la mise en page,
que les donn\'ees, ici les matrices de pixels correspondant aux caract\`eres. Nous avons donc \'et\'e
amen\'e \`a concevoir une fonction permettant de r\'ecup\'erer la matrice binaire d'\`apr\`es les coordonn\'ees
des \'el\'ements (composantes connexes, mots, lignes, paragraphes) ainsi que des fonctions nous permettant de
cr\'eer un fichier de type xml (travail r\'ealis\'e par Alexandre) contenant la hi\'erarchie des \'el\'ements
de la page ainsi que les coordonn\'ees des caract\`eres dans l'image du document. Cependant, un probl\`eme est
survenu. On se devait de standardiser les informations obtenues en matrices de 10 par 10 pixels pour l'entr\'ee
du r\'eseau de neurones, \`a savoir de redimensionner les matrices de pixels.
Or le retard accumul\'e ne nous a pas permis de finir cette \'etape de standardisation.


\section{Bilan}

Au terme du projet, la partie Analyse et extraction permet conformément au cahier des
charges de décomposer une image prétraitée qualifiée de ``parfaite'' en lettres, mots, lignes
et paragraphes. On constate cependant des imprécisions dans les blocs détectés. Elle
permet en outre de stocker en mémoire la structure linéaire du document ainsi que les
données textuelles. Cependant, le retard que nous avons accumulé depuis la dernière
soutenance ne nous a pas permis de terminer l'étape de standardisation des données pour
le réseau de neurones.



\chapter{Interface graphique} % (fold)
\label{cha:interface_graphique}

\section{Pourquoi?} % (fold)
\label{sec:pourquoi_}
L’interface graphique est une partie critique d’un projet. Quoiqu’en disent beaucoup de \emph{geeks}, la ligne de commande n’est pas intuitive. Ce n’est pas le moyen le plus simple de comprendre une application. L’utilisateur lambda a besoin de boutons, parce qu’il n’a plus à s’imaginer une interface en tapant des commandes aux noms douteux, il n’a pas à \emph{apprendre} des mots magique, il n’a qu’à cliquer sur des boutons, faisant alors un parallèle avec le monde qui l’entoure. \\
L’interface graphique rassure l’utilisateur, l’ordinateur n’est plus alors une boite magique, c’est un outil qu’il maîtrise. \\
C’est pour cela que nous offrons à l’utilisateur une interface graphique.\\

Pour le \emph{power user}, la ligne de commande est plus immédiate, elle lui procure une plus grande sensation de contrôle. Beaucoup de \emph{geeks} sont rebutés par des interface graphique trop simplistes. Ils en ont peur, tout simplement. Ils veulent savoir ``ce qu’il y a derrière''. Le fait de taper des lignes eux-mêmes leur apporte un certain pouvoir, ils voient le résultat de leur action dans les lignes qui s’affichent en réponse à leur commande. Ils peuvent tout arrêter quand ils veulent. L’ordinateur est alors un outil qu’ils maîtrisent. \\
C’est pourquoi nous offrons aussi la possibilité à l’utilisateur d’utiliser notre application en ligne de commande.

% section pourquoi_ (end)

\section{Comment?} % (fold)
\label{sec:comment_}
La disposition que nous avons retenu pour notre interface graphique est très simple. Nous nous sommes fixer pour objectif d’avoir le moins de boutons possible, afin que l’utilisateur ait le moins de chance possible de se perdre. 
Nous avons donc opté pour une interface en 4 parties :\\

\begin{itemize}
	\item La barre de menu, pas \emph{nécessaire} ici, mais l’utilisateur doit rester dans un environnement familier, et cela passe par le respect de certains standards,
	\item La barre d’outil, qui contiendra les boutons principaux: open, save, convert,
	\item Un cadre de visualisation de l’image, pour que l’utilisateur vérifie qu’il ne s’est pas tromper de fichier,
	\item Un éditeur de texte avec correcteur orthographique intégré pour visualiser le résultat de la conversion et éventuellement corriger les erreurs de notre logiciel.
\end{itemize}

% section comment_ (end)


\subsection{GTKoi?} % (fold)
\label{sec:gtkoi_}
Au début du projet, avant d’avoir touché à Gtk, nous imaginions qu’il existait un outil assez simple pour créer des interfaces graphiques. Eh oui, nous étions très naïfs à l’époque. \\
Des camarades nous ont parlé de Glade, un outil avec des boutons et dans lequel on peut utiliser la souris pour créer des interface graphique par simple glisser-déposer. C'est plus ou moins vrai. Glade nous aide à créer une interface, mais il ne code pas pour nous! 

Glade 3 fonctionne tr\`es bien sur les machines du PIE. Il a le m\'erite de nous offrir une interface assez intuitive, je l'ai donc pris en main tr\`es rapidement.\\
Nous cr\'eons donc une interface en utilisant Glade puis nous relions chaque ``signal'' dans un \texttt{.c}. Les ``signals'' sont des sortes d'``\'ev\`enement'' auquel on peut relier une action en utilisant Gtk.\\
Pour relier un signal \`a une action, on utilise la fonction suivante:

\begin{lstlisting}
glade_xml_signal_connect (gxml, "on_window_destroy",
			  G_CALLBACK (gtk_main_quit));
\end{lstlisting}

Ici, \verb!gxml! est notre fichier xml, \verb!"on_window_destroy"! est le signal auquel on rattache la fonction Gtk \verb!gtk_main_quit! qui quitte l'application en cours. Cette simple ligne de code nous permet de signifier au programme que lorsqu'on clique sur la ``croix'' en haut \`a droite de notre fen\^etre, il faut non seulement fermer la fen\^etre mais aussi l'application.
On peut bien entendu lui sp\'ecifier d'autres fonctions que celles de Gtk.
% subsection gtkoi_ (end)

\subsection{Enregistrement d'un fichier texte} % (fold)
\label{sec:enregistrement_d_un_fichier_texte}

Pour la premi\`ere soutenance, nous nous \'etions arr\^et\'e \`a l'ouverture d'une image.\\
Pour la deuxi\`eme soutenance, nous nous sommes attaqu\'e \`a la gestion du texte, et plus pr\'ecis\'ement \`a l'enregistrement d'un fichier texte.\\
Les modifications apport\'ees sont relatives au texte. Nous pouvons d\'esormais \'editer du texte, ainsi que l'enregistrer. Soyons francs: la gestion du texte sous Gtk, c'est pas de la tarte. On utilise un widget de type GtkTextView qui nous sert \`a afficher le texte. Pour l'\'editer, on utilise un GtkTextBuffer, qui utilise des GtkTextIter associ\'es \`a des GtkTextMarks. Bref, c'est un merdier sans nom.
Les GtkTextIter servent \`a se rep\'erer dans le GtkTextBuffer (qui est un buffer, thank you captain Obvious!). Un GtkTextIter est un endroit du texte. On l'utilise par exemple pour r\'ecup\'erer une cha\^ine de caract\`eres:
\begin{lstlisting}
 text = gtk_text_buffer_get_text( GTK_TEXT_BUFFER(txtbuffer), 
                            &iStart, 
                            &iEnd, 
                            FALSE );
\end{lstlisting}
Ici, iStart et iEnd sont des pointeurs sur des GtkTextIter (ici le d\'ebut et la fin du buffer, encore une fois, thank you captain obvious!).
Il faut ensuite cr\'eer une proc\'edure pour sauvegarder le texte r\'ecup\'er\'e. En C, on utilise le type \verb!FILE! de la biblioth\`eque \verb!stdio.h!. C'est assez simple pour ce qu'on fait ici. On ouvre un fichier puis on \'ecrit dedans, sans oublier une gestion d'erreur (ici pas forc\'ement tr\`es utile, mais il n'est jamais inutile de g\'erer les erreurs\ldots).

\begin{lstlisting}
void save_as (char *text, char *filename)
{
  FILE *fp;
    /* opens the file in writing mode ("w")*/
  fp = fopen(filename, "w");
  if(!fp)
      /* sends an error message */
    fprintf(stderr, "Can't open file\n");
  else
      /* writes "text" in the file */
    fprintf(fp, text);
    /* closes the file */
  fclose(fp);
}
\end{lstlisting}
% section enregistrement_d_un_fichier_texte (end)

\begin{center}

	\includegraphics[width=120mm]{gui.png}\\
	\caption{\emph{Notre magnifique interface graphique, telle qu'on l'avait pr\'esent\'ee lors de la deuxi\`eme soutenance}}\\
\end{center}


\subsection{Ortaugraffe} % (fold)
\label{sec:ortaugraffe}
	L'utilisateur aura besoin d'un correcteur orthographique non seulement pour corriger les erreurs de notre OCR mais aussi pour \'editer son texte avant de l'enregistrer. Avant de me lancer dans la cr\'eation d'un syst\`eme de correction orthographique, je voyais d\'ej\`a le tableau: des biblioth\`eques compliqu\'ees, des centaines de fonctions qui font tout sauf ce qu'on veut, etc\ldots J'avais en effet fini par devenir tr\`es pessimiste vis-\'a-vis de Gtk. Je dois dire que j'ai \'et\'e bluff\'e. Une ligne. UNE ligne. On utilise la biblioth\`eque \verb!GtkSpell! pr\'esente sur les machines du PIE. Cette fameuse ligne, la voici dans tout sa splendeur:
	\begin{lstlisting}
  gtkspell_new_attach (GtkTextView *view,
                       const gchar *lang,
                       GError **error);
	\end{lstlisting}
	\verb!view! est notre widget \verb!GtkTextView!, \verb!lang! est la langue, \verb!error! est un pointeur sur la localisation d'une erreur \'eventuelle (\verb!NULL! pour nous).

	%%% SCREEN CORREC

% section ortaugraffe (end)

\subsection{Lions!} % (fold)
\label{sub:lions_}
Pour la soutenance finale, ou soutenance de projet, il fallait bien \'evidemment terminer compl\`etement l'interface. Cela signifie lier l'interface graphique aux \'executables existants. \\
Il faut d'abord s'attaquer au probl\`eme de la taille des images. Lors de l'affichage des images dans l'interface graphique, je n'avais pas r\'eussi pour la deuxi\`eme soutenance \`a r\'eduire les images pour qu'on puisse les voir enti\`erement. Si l'on choisissait une grande image, on ne voyait que la partie sup\'erieure gauche.\\
Nous avons r\'eussi \`a r\'esoudre ce problème en rusant, parce que nous n'avons pas trouv\'e de fonction Gtk qui puisse nous venir en aide. Pierre a cr\'e\'e pour moi une option dans son executable \verb!OCRed!, \verb!--resize-auto!, qui r\'eduit les images pour que l'utilisateur puisse voir une vignette de cette image.\\
Pour appeler un \'executable, j'\'etais d'abord parti sur l'utilisation d'un \verb!fork()!, histoire de faire les choses proprement. J'\'etais donc parti sur quelque chose du genre:

\begin{lstlisting}
if(!fork())   
  {
    /* on est dans le fils */
      system("make");  
    execl("../bin/OCRed", "-i", "filename", "--resize-auto", NULL);
    /* NULL est une "sentinelle" qui indique la fin des arguments */
    exit(0); /* on quitte le fils */
  }
  else
  { /* on est dans le pere */
    wait(NULL); /* on attend la fin du fils */
  }
\end{lstlisting}

Malheureusement, \c ca n'a pas march\'e, et on ne sait toujours pas pourquoi. Ce n'est pas faute de pers\'ev\'erance\ldots j'ai litt\'eralement pass\'e des \emph{heures} dessus! Et faites moi confiance, ce n'est pas ce qu'il y a de plus gratifiant que de passer plusieures heures sur quelques lignes de codes sans avoir le plaisir de d\'ecouvrir ce qui n'allait pas au final. Je suis donc pass\'e \`a une commande plus ``magique'', \verb!system()!. \verb!system()! prend en param\`etre une cha\^ine de caract\`ere, la commande, et l'\'ex\'ecute comme si l'on avait tap\'e cette cha\^ine nous-m\^eme en ligne de commande.
% subsection lions_ (end)
% chapter interface_utilisateur (end)




% chapter interface_graphique (end)

\end{document}
